# 结构体

> - 结构体类型的声明
> - 结构体初始化
> - 结构体成员的访问
> - 结构体传参

## 1. 结构体的声明



### 1.1 结构的基础知识

> 结构是一些值的集合，这些值称为成员变量。结构的成员可以是不同类型的变量。



### 1.2 结构的声明

```c
struct tag
{
    member-list;
}variable-lsit;
```

```c
//描述一个学生的一些数据
//姓名
//年龄
//性别
//电话

//struct - 结构体关键字
//Stu - 结构体标签
//struct Stu - 结构体类型
//定义一个结构体类型
/*struct Stu
{
    //成员变量
    char name[20];
    short age;
    char gender[5];
    char tel[11];
}s1, s2, s3; //s1, s2, s2是三个全局的结构体变量，不建议*/

typedef struct Stu  //给struct Stu这个类型重新起名叫Stu
{
    //成员变量
    char name[20];
    short age;
    char gender[5];
    char tel[11];
}Stu;  // Stu是类型

 int main()
 {
     //创建结构体变量
     struct Stu s1; //s1是局部的结构体变量
     Stu s2;
     
     return 0;
 }
```



## 2.  结构体变量的定义和初始化

```c
struct Point
{
    int x;
    int y;
}p1;                   // 声明类型的同时定义了变量p1
struct Point p2;       // 定义结构体变量p2

//初始化：定义变量的同时赋初始值
struct Point p3 = {x,y};
```

```c
typedef struct Stu  //给struct Stu这个类型重新起名叫Stu
{
    //成员变量
    char name[20];
    short age;
    char gender[5];
    char tel[11];
}Stu;  // Stu是类型

 int main()
 {
     //初始化：定义变量的同时赋初始值
     Stu s1 = {"张三", 20, "男", "15384882321"}; //s1是局部的结构体变量
     Stu s2 = {"李四", 21, "男", "15384882322"};
     return 0;
 }
```

```c
typedef struct S
{
    int a;
    char c;
    char arr[20];
    double d;
}S;

typedef struct T
{
    char ch[10];
    S s;  // 结构体成员变量中可以包含其他结构体(嵌套)
    char* pc;
}T;

int main()
{
    char arr[] = "hello"
    T t = {"hehe", {100, "w", "hello world", 3.14}, arr};
    printf("%s\n", t.ch); //hehe
    printf("%s\n", t.s.arr); //"hello world"
    printf("%lf\n", t.s.d); //3.14
    printf("%s\n", t.pc); //hello
    return 0;
}
```



## 3.  结构体成员的访问和传参

- 结构体变量访问成员   结构体变量的成员是通过点操作符（.）访问的，点操作符接收两个操作数。

- 结构体指针访问指向变量的成员  有时候我们得到的不是一个结构体变量，而是指向一个结构体的指针。

  ```c
  typedef struct Stu  
  {
      //成员变量
      char name[20];
      short age;
      char gender[5];
      char tel[11];
  }Stu;
  
  void Print1(Stu tmp)
  {
      printf("name: %s\n", tmp.name);
      printf("age: %d\n", tmp.age);
      printf("gender: %s\n", tmp.gender);
      printf("tel: %s\n", tmp.tel);
  }
  
  void Print2(Stu* ps)
  {
      printf("name: %s\n", ps->name);
      printf("age: %d\n", ps->age);
      printf("gender: %s\n", ps->gender);
      printf("tel: %s\n", ps->tel);
  }
  
  int main()
  {
      Stu s = {"李四", 40, "男", "15991631198"};
      //Print1和Print2哪个更好？
      //Print2更好！Print1传参时会有一份临时拷贝，这既费时也费空间
      Print1(s);
      Print2(&s);
      return 0;
  }
  ```

  Print1和Print2哪个更好？

  首选Print2，理由如下：

  > 函数传参的时候，参数是需要压栈的。如果传递与i个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降。

  结论：<u>结构体传参的时候，要传结构体的地址。</u>

  

## *补充*

> 内存分三块：栈区、堆区、静态区
>
> - 栈区：局部变量、函数形参、函数调用也开辟空间
> - 堆区：动态内存分配，涉及的函数有malloc/free、realloc、calloc
> - 静态区：全局变量、静态变量
>
> 数据结构：
>
> ----线性结构----
>
> - 顺序表     123456
> - 链表         
> - 栈            压栈（插入一个元素）、出栈（删除一个元素）只能通过栈顶，是所谓： 先进后出，后进先出
> - 队列
>
> ----非线性结构----
>
> - 二叉树
> - 图

```c
#include <stdio.h>

int Add(int x, int y)
{
    int z = 0;
    z = x + y;
    return z;
}

int main()
{
    //main函数调用的时候在栈区开辟一块空间
    //然后分配一部分给a， b， c
    //然后传参：从右向左传，先传b再传a
    //在main空间的上面会开辟两块空间y（b）， x（a）
    //再往上就是Add函数的空间， 其中有一部分是分配给z的空间
    int a = 10;
    int b = 20;
    int c = 0;
    c = Add(a, b);  
    printf("%d\n", c);
    return 0;
}
```

Here are some projects created during my course of leaning C language, including function, operator, array, pointer, structure . Etc. It's in continuous update. And let's make more progress together!