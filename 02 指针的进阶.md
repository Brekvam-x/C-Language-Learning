# 指针的进阶 ^20220424
---
## 本章重点
1. 字符指针
2. 数组指针
3. 指针数组
4. 数组传参和指针传参
5. 函数指针
6. 函数指针数组
7. 指向函数指针数组的指针
8. 回调函数
9. 指针和数组面试题的详解

---

> 指针的基础回顾
> 	1. 指针就是个变量，用来存放地址，地址唯一标识一块内存空间。
> 	2. 指针的大小是固定的4/8字节（32位/64位平台）。
> 	3. 指针是有类型的，指针的类型决定了指针的+-整数的步长，以及指针解引用操作时能访问的字节数。
> 	4. 指针的运算

---

## 字符指针
一般用法：
```c
int main()
{
	char ch = 'w';
	char* pc = &ch;
	return 0;
}
```
---

另外一种用法：
```c
int main()
{
	char arr[] = "abcdef";
	//arr是首元素的地址
	char* pc = arr;
	printf("%s\n", arr); //abcdef
	printf("%s\n", pc); //abcdef
	
	return 0;
}
```
---

还有一种：
```c
int main()
{
	const char* p = "abcdef"; //"abcdef"时常量字符串
	//printf("%c\n", *p); //a，其实和上面的道理一样的，取首元素地址赋给p
	//printf("%s\n", p); //"abcdef"，从p的地址开始打印字符串
	*p = 'W';
	printf("%s\n", p);//Segment fault 段错误--非法访问内存
	//"abcdef"时常量字符串，不能改变
	return 0;
}
```
---

**面试题：**
	下面代码的输出结果是什么？
```c
#include <stdio.h>
int main()
{
	char arr1[] = "abcdef";
	char arr2[] = "abcdef";
	//两个常量字符串是一样的，为了节省空间，p1和p2指向的都是同一个常量字符串的首元素地址
	const char* p1 = "abcdef";
	const char* p2 = "abcdef";
	
	//haha
	/*if (arr1 == arr2)
	{
		printf("hehe\n");
	}
	else
	{
		printf("haha\n");
	}*/
	
	//hehe
	if (p1 == p2)
	{
		printf("hehe\n");
	}
	else
	{
		printf("haha\n");
	}
	return 0;
}
```
---
## 指针数组
> 指针数组：用来存放指针的数组。
```c
int main()
{
	int arr[10] = { 0 }; //整型数组
	char ch[10] = { 0 }; //字符数组
	int* parr[4]; //存放整型指针的数组 - 指针数组
	char* pch[4]; //存放字符指针的数组 - 指针数组
	return 0;
}
```
---

指针数组的基础应用：
```c
int main()
{
	int a = 10;
	int b = 20;
	int c = 30;
	int d = 40;
	int* arr[4] = { &a,&b,&c,&d };
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		printf("%d\n", *(arr[i]));
	}
	return 0;
}
```
---

指针数组的进阶应用：
```c
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 2,3,4,5,6 };
	int arr3[] = { 3,4,5,6,7 };
	int* parr[] = { arr1,arr2,arr3 };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			printf("%d ", *(parr[i] + j));
		}
		printf("\n");
		
	}
	return 0;
}
```
---

## 数组指针
---

### 数组指针的定义
> 能够指向数组的指针。

```c
int main()
{
	int* p = NULL; //p是整型指针
	char* pc = NULL; //pc是字符指针
	//数组指针 - 指向数组的指针
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//arr - 首元素地址
	//&arr[0] - 首元素地址
	//&arr - 数组的（起始）地址
	//int* p = &arr; //整型指针不能存放数组地址
	int (*p)[10] = &arr;
	//上面的p就是数组指针
	return 0;
}
```
```c
int main()
{
	char* arr[5];
	char* (*pa)[5] = &arr;
	//char*表示pa指向的数组中每个元素都是字符型指针，(*pa)表示指针，[5]表示是pa指向的数组有5个元素
	return 0;
}
```
---
### 数组指针的使用
```c
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(p + i));
	}
	//int (*pa)[10] = &arr;
	//int i = 0;
	/*for (i = 0; i < 10; i++)
	{
		printf("%d ", (*pa)[i]);
	}*/
	/*for (i = 0; i < 10; i++)
	{
		printf("%d ", *(*pa + i));
	}*/
	
	return 0;
}
```
---

一般数组指针用于二维数组。
```c
#include <stdio.h>

//参数是数组的形式
void print1(int arr[3][5], int x, int y)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	
}

//参数是指针的形式
void print2(int (*p)[5], int x, int y)
{
	int i = 0;
	for (i = 0; i < x; i++)
	{
		int j = 0;
		for (j = 0; j < y; j++)
		{
			//printf("%d ", *(*(p + i) + j));
			//printf("%d ", *(p + i)[j]);
			printf("%d ", p[i][j])
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { { 1,2,3,4,5 }, { 2,3,4,5,6 }, { 3,4,5,6,7 } };
	print1(arr, 3, 5);//arr - 数组名 - 数组名就是首元素的地址（首元素是第一行）
	print2(arr, 3, 5);
	//arr[i] <==> *(arr + i) <==> *(p + i) <==> p[i]
	//arr[i][j] <==> *(*(arr + i) + j) <==> p[i][j]
	return 0;
}
```
---

**解释下面的语句**
```c
int arr[5];              //arr是一个包含5个元素的数组
int *parr1[10];          //parr1是一个数组，有10个元素，每个元素类型都是int* - 指针数组
int (*parr2)[10];        //parr2是一个指针，指向一个包含10个元素的数组，其中每个数组元素的类型都是整型 - 数组指针
int (*parr3[10])[5];     //parr3是一个数组，该数组有10个元素，每个元素是一个数组指针，该数组指针指向的数组有5个元素，每个元素是int
```
---

## 数组传参、指针参数
---

### 一维数组传参

> 形式参数可以写成数组（数组大小可以省略），也可以写成指针

---
```c
#include <stdio.h>

void test(int arr[])//ok? - ok
{}

void test(int arr[10])//ok? - ok - 10可以省略
{}

void test(int *arr)//ok? - ok
{}

void test2(int *arr[20])//ok? - ok - 20可以省略
{}

void test2(int **arr)//ok? - ok

int main()
{
	int arr[10] = {0};
	int *arr2[20] = {0};
	test(arr);
	test2(arr2);
	return 0;
}
```
---

### 二维数组传参
---

> 二维数组传参，函数形参的设计只能省略第一个[]的数字
> 移位对于一个二维数组，可以不知大多少行，但是必须知道一行有多少元素，这样才方便运算

---

```c
#include <stdio.h>

void test(int arr[3][5]) //ok
{}

void test1(int arr[][5]) //ok - 行可省略，列不能省
{}

//void test2(int arr[][]) //error - 列不可省略
//{}

//void test3(int *arr) //error
//{}

//void test4(int **arr) //error
//{}

void test5(int (*arr)[5]) //ok
{}

int main()
{
	int arr[3][5] = {0};
	
	//test(arr);//二维数组传参
	//test1(arr);
	//test3(arr);
	//test4(arr);
	test5(arr);
	return 0;
}
```
---

### 一级指针传参
---

> 一级指针传参，形参类型为指针，则可以传地址或指向该地址的指针。

---

```c
#include <stdio.h>

void print(int *p, int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", *(p + i));
	}
}


int main()
{
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
	int *p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);
	print(p, sz);
	return 0;
}
```
思考：
```c
#include <stdio.h>

void test1(int* p)
{}

void test2(char* p)
{}

int main()
{
	int a = 10;
	int* p1 = &a
	test1(&a); //ok,传地址
	test1(p1); //ok
	char ch = 'w';
	char* pc = &ch;
	test2(&ch);//ok
	test2(pc);//ok
	return 0;
}
```
---
### 二级指针传参
---
> 二级指针传参，可以传指针的地址、二级指针或者指针数组的数组名

---

```c
#include <stdio.h>

void test(int** ptr)
{
	printf("num = %d\n", **ptr);
}

int main()
{
	int n = 10;
	int* p = &n;
	int** pp = &p;
	test(pp);
	test(&p);
	return 0;
}
```
思考：
```c
void test(int** ptr)
{}

int main()
{
	int* p;
	int** pp = &p;
	int* arr[10];
	test(&p); //ok
	test(pp); //ok
	test(arr); //指针数组的首元素（一个指针）的地址，也就是二级指针
	return 0;
}

```
---
## 函数指针
---

> 函数指针：指向函数的指针
> 函数名和&函数名都是指向函数的地址

---
### 函数指针的定义
```c
#include <stdio.h>

int Add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}

int main()
{
	int a = 10;
	int b = 20;
	//printf("sum = %d\n", Add(a, b));
	//printf("%p\n", &Add); //009110E1
	//printf("%p\n", Add); //009110E1
	int (*pa)(int, int) = Add;
	//首先(*pa)表明是一个指针，其类型是int (int, int)
	//其中，第一个int是指函数的返回值的类型是整型，括号里面的int表示函数的两个形参的类型是整型
	//当然，也可以写int (int x, int y)，一般只写类型即可，x、y可以省略
	printf("%d\n", (*pa)(2, 3)); //5
	printf("%d\n", (**pa)(2, 3)); //5
	printf("%d\n", (***pa)(2, 3)); //5
	//说明对于函数来说，这些*不起作用，可以直接省略
	//但是加上一个*比较容易理解
	printf("%d\n", (pa)(2, 3)); //5
	//可以这样理解：Add <==> pa，因此还可以这样写：
	printf("%d\n", pa(2, 3)); //5
	//这里的*pa就是指Add函数，(*pa)(2, 3) <==> Add(2, 3)
	return 0;
}
```
---
### 两段有趣的代码
```c
//代码1
(*(void (*)())0)();
//首先，void (*)()是一个函数指针，其类型是void ()
//然后将这个函数指针括起来放在0的前面，意思是将0进行强制类型转换，转换成void (*)() 函数指针类型 - 现在0就是一个函数的地址
//前面的*就是解引用操作，调用void (*)()这个函数指针的地址，即0地址处的该函数

//代码2
void (*signal(int , void(*)(int)))(int);
//首先，signal(int, void(*)(int))是一个函数，有两个参数，分别为int类型和void(*)(int)类型，其中，void(*)(int)是一个函数指针，其类型为void (int)。函数的返回类型是void (*)(int) - 一个函数指针。
//总而言之，这就是一个函数的声明语句，其中函数名是signal，函数的参数有两个，一个是int类型，另一个是函数指针，该函数指针指向的函数的参数是int，返回类型为void。signal函数返回值也是一个函数指针，该函数指针指向的函数的参数是int，返回类型为void。

//代码2可以精简一些：
//typedef的用法：
typedef unsigned int u_int;

//同理，可以将函数指针类型重命名为ptr_fun
typedef void(* ptr_fun)(int); 
//从而简化得到：
prt_fun signal(int, ptr_fun);
```
---

## 函数指针数组
---

> 函数指针数组：用于存放函数指针的数组

---

### 函数指针数组的定义
#### 定义
---
```c
int Add(int x, int y)
{
	return x + y;
}

int Sub(int x, int y)
{
	return x - y;
}

int Mul(int x, int y)
{
	return x * y;
}

int Div(int x, int y)
{
	return x / y;
}

int main()
{
	//指针数组
	int* arr[5];
	int (*pa)(int, int) = Add; //Sub, Mul, Div
	//需要一个数组，这个数组可以存放4个函数的地址 - 函数指针数组
	//parr[4]是一个数组，其类型为int(* )(int, int)
	int (*parr[4])(int, int) = {Add, Sub, Mul, Div};
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		printf("%d\n", parr[i](2, 3));
	}
	//5 -1 6 0
}
```
---
#### 练习
```c
#include <stdio.h>
char* my_strcpy(char* dest, const char* src)
{
		
}

int main()
{
	//1.写一个函数指针pf，能指向my_strcpy
	char* (*pf)(char*, const char*) = my_strcpy;
	//2.写一个函数指针数组pfArr，能够存放my_strcpy函数的地址
	char* (*pfArr[4])(char*, const char*) = { my_strcpy };
	return 0;
}
```
---
### 函数指针数组的用途：转移表
#### 例1：计算器
```c
#include <stdio.h>
void menu()
{
	printf("************************\n");
	printf("*********1. ADD*********\n");
	printf("*********2. SUB*********\n");
	printf("*********3. MUL*********\n");
	printf("*********4. DIV*********\n");
	printf("*********0. EXIT********\n");
	printf("************************\n");
}

int Add(int x, int y)
{
	return x + y;
}

int Sub(int x, int y)
{
	return x - y;
}

int Mul(int x, int y)
{
	return x * y;
}

int Div(int x, int y)
{
	return x / y;
}

int main()
{
	//初始化选择
	int intput = 0;
	//初始化操作数
	int x = 0;
	int y = 0;
	//定义一个函数指针数组 - 转移表
	int (*pfArr[])(int, int) = {0, Add, Sub, Mul, Div};
	//计算函数指针数组内元素的个数
	int sz = sizeof(pfArr) / sizeof(pfArr[0]);
	do
	{
		menu();
		printf("请选择：");
		scanf_s("%d", &input);
		if (input >= 1 && input <= sz - 1)
		{
			printf("请输入两个操作数 --> ");
			scanf_s("%d %d", &x, &y);
			int ret = pfArr[input](x, y);
			printf("%d\n", ret);
		}
		else if (input == 0)
		{
			printf("退出\n");
		}
		else
		{
			printf("选择错误\n");
		}
		/*switch (input)
		{
			case 1:
				printf("请输入两个操作数 --> ");
				scanf_s("%d %d", &x, &y);
				printf("结果为：%d\n"，Add(x, y));
				break;
			case 2:
				printf("请输入两个操作数 --> ");
				scanf_s("%d %d", &x, &y);
				printf("结果为：%d\n"，Sub(x, y));
				break;
			case 3:
				printf("请输入两个操作数 --> ");
				scanf_s("%d %d", &x, &y);
				printf("结果为：%d\n"，Mul(x, y));
				break;
			case 4:
				printf("请输入两个操作数 --> ");
				scanf_s("%d %d", &x, &y);
				assert
				printf("结果为：%d\n"，Div(x, y));
				break;
			case 0:
				printf("退出\n");
				break;
			default:
				printf("选择错误\n");
				break;
		}*/
	}while(input);
	return 0;
}
```
---
## 指向函数指针数组的指针
---
```c
int Add(int x, int y)
{
	return x+y;
}

int main()
{
	int arr[10] = {0};
	int (*p)[10] = &arr; //取出数组的地址存到数组之阵中
	int (*pfArr[4])(int, int); //函数指针数组
	int (*(*ppfArr)[4])(int, int) = &pfArr;
	//ppArr是一个数组指针，指针指向的数组有4个元素
	//指向的数组的每个元素的类型都是一个函数指针 int(*)(int, int)
	//
	return 0;
}```
---
## 回调函数
---

> 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，二十在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

---
```c
#include <stdio.h>
void menu()
{
	printf("************************\n");
	printf("*********1. ADD*********\n");
	printf("*********2. SUB*********\n");
	printf("*********3. MUL*********\n");
	printf("*********4. DIV*********\n");
	printf("*********0. EXIT********\n");
	printf("************************\n");
}

int Add(int x, int y)
{
	return x + y;
}

int Sub(int x, int y)
{
	return x - y;
}

int Mul(int x, int y)
{
	return x * y;
}

int Div(int x, int y)
{
	return x / y;
}

void Calc(int (*pf)(int, int))
{
	//初始化操作数
	int x = 0;
	int y = 0;
	printf("请输入两个操作数 --> ");
	scanf_s("%d %d", &x, &y);
	printf("结果为：%d\n"，pf(x, y));
}

int main()
{
	//初始化选择
	int intput = 0;
	//定义一个函数指针数组 - 转移表
	int (*pfArr[])(int, int) = {0, Add, Sub, Mul, Div};
	do
	{
		menu();
		printf("请选择：");
		scanf_s("%d", &input);
		//这样避免代码冗余
		switch (input)
		{
			case 1:
				Calc(Add);
				break;
			case 2:
				Calc(Sub);
				break;
			case 3:
				Calc(Mul);
				break;
			case 4:
				Calc(Div);
				break;
			case 0:
				printf("退出\n");
				break;
			default:
				printf("选择错误\n");
				break;
		}
	}while(input);
	return 0;
}
```
---
```c
#include <stdio.h>

void print(char* str)
{
	printf("hehe: %s\n", str);
}

void test(void (*p)(char*))
{
	printf("test\n");
	p("bit");
}

int main()
{
	test(print);
	return 0;
}
```
---
```c
//冒泡排序
//之前的只能排序整型数组
void Swap(int* x, int* y)
{
	int tmp = *x;
	*x = *y;
	*y = tmp;
}

void BubbleSort(int arr[], int sz)
{
	int i = 0;
	//趟数是sz-1
	for (i = 0; i < sz - 1; i++)
	{
		//假设数组有序
		int flag = 1;
		int j = 0;
		//每趟要比较sz-i-1次
		for (j = 0; j < sz - i -1; j++)
		{
			if(arr[j] > arr[j + 1])
			{
				Swap(&arr[j], &arr[j + 1]);
				//发生交换，本趟没有完成排序，循环继续
				flag = 0;
			}
		}
		//如果本趟已经有序，则排序完成，循环结束
		if (flag == 1)
		{
			break;
		}
	}
}

int main()
{
	int arr[] = {1,3,2,6,8,7,5,9,10};
	int sz = sizeof(arr) / sizeof(arr[0]);
	BubbleSort(arr, sz);
	return 0;
}
```
---
