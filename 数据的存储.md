# 深度剖析数据在内存中的存储

------

## 1. 本章重点

1. 数据类型详细介绍
2. 整型在内存中的存储：原码、反码、补码
3. 大小端字节序介绍及判断
4. 浮点型在内存中的存储解析



## 2. 数据类型介绍

C语言的数据类型分两类：内置类型、自定义类型（构造类型）

基本的内置类型：

```c
char                       //字符数据类型，1byte

short                      //短整型，2bytes

int                        //整型，4bytes

long                       //长整型，4bytes

long long                  //更长的整型，8bytes

float                      //单精度浮点型，4bytes

double                     //双精度浮点型，8bytes

```

类型的意义：

1. 使用这个类型开辟的内存空间大小（大小决定了使用范围）
2. 决定了如何看待内存空间的视角



## 3. 类型的基本归类

### 整型家族

```c
char                       //char在内存中以ASCII码值存储，相当于用整数进行存储
    unsigned char          //无符号 - 最高位不是符号位，范围是0~255
    signed char            //有符号 - 最高位是符号位，0表示正，1表示负，范围是-128~+127
short
    unsigned short [int]   //int可省略
    signed short [int]
int 
    unsigned int
    signed int
long
    unsigned long [int]
    signed long [int]
```



### 浮点型家族

```c
float
double
```



### 构造类型

- 数组类型    int arr[10]     数组类型：去掉数组名  -->  int [10]
- 结构体类型  struct
- 枚举类型  enum
- 联合类型  union



### 指针类型

```c
int *pi;
char *pc;
float* pf;
void* pv;
//*可以靠近变量，也可以靠近类型
```



### 空类型

> void表示空类型（无类型）
>
> 通常用于函数的返回类型，函数的参数、指针类型
>
> ```c
> #include <stdio.h>
> void test(void)     //void可以省略，表示函数无参数，若不省略，不能传参；若省略，传进来的参数不会使用，但无提醒
> {
>     printf("hehe\n");
> }
> 
> int main()
> {
>     test(100);
>     return 0;
> }
> ```



## 4. 整型在内存中的存储

```c
#include <stdio.h>

int main()
{
    int a = 20;
    //00000000 00000000 00000000 00010100 - 原码
    //00000000 00000000 00000000 00010100 - 反码
    //00000000 00000000 00000000 00010100 - 补码
    //0x00000014
    int b = -10;
    //10000000 00000000 00000000 00001010 - 原码
    //11111111 11111111 11111111 11110101 - 反码
    //11111111 11111111 11111111 11110110 - 补码
    //0xFFFFFFF6
    return 0;
}
```

a和b分配的4字节空间如何存储？

先了解下面的概念：

原码、反码、补码：

> 计算机中*<u>有符号整数</u>*有三种表示方法，即原码、反码和补码。
>
> *无符号数的原码、反码和补码相同。*
>
> 均由**符号位**和**数值位**两部分组成，符号位0为正，1为负。

> **原码**
>
> 直接将二进制按照正负数的形式翻译成二进制就可以。
>
> **反码**
>
> 符号位不变，其余位按位取反
>
> **补码**
>
> 反码+1

**对于整形来说：数据中存放的是补码**。

为什么呢？

> 使用补码，可以将符号位和数值位统一处理，同时，加法和减法也可以统一处理（CPU只有加法器），此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
>
> ```c
> int main()
> {
>     1 - 1;
>     //1+(-1)
>     //00000000 00000000 00000000 00000001 - 1的原码
>     //10000000 00000000 00000000 00000001 - -1的原码
>     //10000000 00000000 00000000 00000010  - -2 错误
>     
>     //00000000 00000000 00000000 00000001 - 1的补码
>     //11111111 11111111 11111111 11111111 - -1的补码
>     //00000000 00000000 00000000 00000000 - 0
>     return 0;
> }
> ```

### 大小端介绍

什么是大小端？

> 大端（字节序存储）模式，是指数据的低位保存在内存的高地址中，高位保存在内存的低地址中。 - 顺序
>
> 小端（字节序存储）模式，是指数据的低位保存在内存的低地址中，高位保存在内存的高地址中。 - 反顺序
>
> VS采用小端

#### 百度2015年系统工程师笔试题

> 请简述大小端字节序的概念，设计一个小程序来判断当前机器的字节序。

```c
//大端字节序模式：数据的低位保存在内存的高地址中，高位保存在内存的低地址中
//小端字节序模式：数据的低位保存在内存的低地址中，高位保存在内存的高地址中

//计算机会选择一种模式，所以只需要用一个简单的数字来测试就可以知道计算机是用大端还是小端
#include <stdio.h>
//函数内部最好不要进行打印
int check_sys()
{
    int a = 1;
    //指针类型的意义
    //1. 决定了解引用指针能访问的字节d
    //2. 决定了指针+1、—1跨越的字节数，也就是步长
    //char* pa = &a;  //系统警告：从int*到char*，类型不兼容，需强制转换
    /*
    char* pa = (char*) &a;
    //返回1-小端，0-大端
    return *p;
    */
    //直接简化
    //返回1-小端，0-大端
    return (*(char*) &a);
}

int main()
{
    int ret = check_sys();
    if(ret == 1)
    {
        printf("小端\n");
    }
    else
    {
        printf("大端\n");
    }
    return 0;
}
```



### 练习1

> 下面的程序输出什么？

```c
#include <stdio.h>

int main()
{
    char a = -1;
    //10000000 00000000 00000000 00000001 - 原码
    //11111111 11111111 11111111 11111110 - 反码
    //11111111 11111111 11111111 11111111 - 补码
    //11111111
    //整型提升 --> 按符号位填1
    //11111111 11111111 11111111 11111111 - 补码
    //10000000 00000000 00000000 00000001 - 原码 -1
    
    signed char a = -1;
    //11111111
    //整型提升 --> 按符号位填1
    //11111111 11111111 11111111 11111111 - 补码
    //10000000 00000000 00000000 00000001 - 原码 -1
    
    unsigned char a = -1;
    //11111111
    //整型提升 --> 按符号位填0
    //00000000 00000000 00000000 11111111 - 补码
    //00000000 00000000 00000000 11111111 - 原码 255
    
    printf("a=%d, b=%d, c=%d", a, b, c);//-1 -1 255
    return 0;
}
```



### 练习2

> 下面的程序输出什么？

```c
#include <stdio.h>

int main()
{
    char a = -128;
    //10000000 00000000 00000000 10000000 - 原码
    //11111111 11111111 11111111 01111111 - 反码
    //11111111 11111111 11111111 10000000 - 补码
    //10000000
    //整型提升 - 填1
    //11111111 11111111 11111111 10000000 - 补码
    
    printf("%u\n", a); //2^32-2^7
    // %d - 打印十进制的有符号数字
    // %u - 打印十进制的无符号数字
    //11111111 11111111 11111111 10000000 - 原码
    return 0;
}
```

> 有符号负数填1，无符号负数填0
>
> 默认的是有符号数，%d - 十进制有符号整数   %u - 十进制无符号整数



### char类型范围的定义

> 一个byte，8个bit，一共2^8=256种序列，有符号数：-128~127，无符号数：0~255
>
> 【*注意：1000 0000 - 补码和原码相同，就是-128*】
>
> *思考1：下面的程序输出什么？*
>
> ```c
> #include <stdio.h>
> 
> int main()
> {
>     char a = -128;
>     //10000000 00000000 00000000 10000000 - 原码
>     //11111111 11111111 11111111 01111111 - 反码
>     //11111111 11111111 11111111 10000000 - 补码
>     //10000000
>     //整型提升 - 有符号负数填1
>     //11111111 11111111 11111111 10000000 - 补码
>     printf("%u\n", a); //2^32-2^7
>     return 0;
> }
> ```
>
> *思考2：下面的呢？*
>
> ```c
> #include <stdio.h>
> 
> int main()
> {
>     char a = 128;//最大范围是127，128相当于是127+1  --> 结果也是-128
>     printf("%u\n", a); //2^32-2^7
>     return 0;
> }
> ```
>
> <img src="C:\Users\24398\AppData\Roaming\Typora\typora-user-images\image-20220423083911236.png" alt="image-20220423083911236" style="zoom: 33%;" />

### 练习3

> 下面程序输出的结果？

```c
#include <stdio.h>

int main()
{
    int i = -20;
    //10000000 00000000 00000000 00010100 - 原码
    //11111111 11111111 11111111 11101011 - 反码
    //11111111 11111111 11111111 11101100 - 补码
    unsigned int j = 10;
    //00000000 00000000 00000000 00001010 - 补码
    //相加i+j
    //11111111 11111111 11111111 11110110 - 补码
    //11111111 11111111 11111111 11110101 - 反码
    //10000000 00000000 00000000 00001010 - 原码 - 有符号 - -10
    printf("%d\n", i+j);
    return 0;
}
```



### 练习4

> 下面的程序输出什么？
>
> 死循环

```c
#include <stdio.h>
#include <windows.h>

int main()
{
    unsigned int i;
    //无符号整数永远都是大于等于0，所以会一直循环
    for (i = 9; i >= 0; i--)
    {
        printf("%u\n", i);
        sleep(100); //休眠100ms
    }
    return 0;
}
```



### 练习5

> 下面的程序输出什么？

```c
#include <stdio.h>
#include <string.h>

int main()
{
    char a[1000];
    int i;
    for (i = 0; i < 1000; i++)
    {
        a[i] = -1-i;
    }
    //a[0]=-1
    //a[1]=-2
    //...
    //a[127]=-128
    //a[128]=127
    //a[129]=126
    //a[255]=0    -  到这里0是'\0'的ASCII码值，所以strlen计算到下标254为止，结果是255
    printf("%d", strlen(a));
    return 0;
}
```



### 练习6

> 下面程序输出的结果是多少？

```c
#include <stdio.h>

unsigned char i = 0;
int main()
{
    //无符号字符型范围是0~255，255+1 --> 0，从而陷入死循环
    for (i = 0; i <= 255; i++)
    {
        printf("hello world\n");
    }
    return 0;
}
```



## 5. 浮点型在内存中的存储

常见的浮点数：

> 3.141591E10     浮点数家族包括：float、double、long double类型，浮点数表示的范围：float.h中定义
>
> *注释：1E10表示1.0*10^10*

浮点数存储的例子：

```c
#include <stdio.h>
//9.0
//写成二进制形式：1001.0
//(-1)^0 * 1.001 * 2^3
//(-1)^S * M     * 2^E
//S=0, M=1.001, E=3
int main()
{
    int n = 9;
    float *pFloat = (float *)&n;
    printf("n的值为：%d\n", n); //9
    //整数放进去，浮点数的形式取出
    printf("*pFloat的值为：%f\n", *pFloat); //0.000000
    
    *pFloat = 9.0;
    //浮点数放进去，整型的形式取出
    printf("n的值为：%d\n", n); //1091567616
    printf("*pFloat的值为：%f\n", *pFloat);//9.000000
    return 0;
}
```

根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成一下形式：

> - (-1)^S * M * 2^E
> - (-1)S表示符号位，当S=0，V为正数；当S=1，V为负数
> - M表示有效数字，1 <= M < 2
> - 2^E表示指数位

**IEEE 754规定**：

SEM

对于32位（float，单精度浮点型）的浮点数，最高的1位是符号位，接着的8位时指数E，剩下的23位为有效数字M

> S(1 bit) + E(8 bit) + M(23 bit)

对于64位（double，双精度浮点型）的浮点数，最高的1位是符号位，接着的11位时指数E，剩下的52位为有效数字M

> S(1 bit) + E(11 bit) + M(52 bit)

**IEEE 754对有效数字M和指数E，还有一些特别规定。**

1≤M<2，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。

> 在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面xxxxxx的部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有32位，将第一位的1舍去以后，等于可以保存24位有效数字。

**至于指数E，情况就比较复杂。**

> 首先，E为以一个无符号整数（unsigned int），这意味着，如果E为8位，其取值范围是0~255；如果E为11位，其取值范围是0~2047。但是，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数时127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数是，必须保存成10+127=137，即10001001。
>
> 练习：9.0在内存中的表示为：
>
> 首先，9.0的二进制表示为1001.0
>
> (-1)^0 * 1.001 * 2^3
>
> S=0, M=001（前面填0，补充成23位）, E=3+127=130(1000 0010)
>
> 0 10000010 00000000 00000000 0000001
>
> 0100 0001 0000 0000 0000 0000 0000 0001  -->  0x41 00 00 01  -->小端：01 00 00 41

然后，指数E从内存中取出还可以在分成三种情况：

**E不全为0或不全为1** (常规的情况)

> 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1，比如：0.5的二进制表示为0.1，由于规定正数部分必须为1，即将小数点右移1位，即为1.0*2^(-1)，其解码为-1+127 = 126，表示为01111110，而尾数1.0去掉正数部分为0，不起0到23位，00000000000000000000000，则其二进制表示为：1 00000000 00000000000000001111110
>
> 1000 0000 0000 0000 0000 0000 0111 1110   --> 0x80 00 00 7E  -->小端：7E 00 00 80

**E全为0**

> 这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再是加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。

**E全为1**

> 这时，如果有效数字M全为1，表示±∞（正负取决于符号位S）。
